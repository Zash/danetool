#!/usr/bin/env lua5.1

local socket = require "socket";
local mime = require "mime";
local ssl = require "ssl";
local unbound = require "lunbound";

local crypto = require "crypto";

local hashes = {};
function hashes.sha256(data, hex)
	return crypto.digest("sha256", data, not hex);
end
function hashes.sha512(data, hex)
	return crypto.digest("sha512", data, not hex);
end

local function tohex(s)
	return s:gsub(".", function (c)
		return ("%02x"):format(c:byte());
	end);
end

-- from prosody util.x509
local pat = "%-%-%-%-%-BEGIN ([A-Z ]+)%-%-%-%-%-\r?\n"..     
	"([0-9A-Za-z+/=\r\n]*)\r?\n%-%-%-%-%-END %1%-%-%-%-%-";      

local function pem2der(pem)                                  
	local typ, data = pem:match(pat);                          
	if typ and data then                                       
		return mime.unb64(data), typ;                         
	end                                                        
end                                                          

local tlsa_mt = {};

-- from luaunbound util.dns
local function parse_TLSA(packet)                    
  local use, select, match = packet:byte(1,3);
  return setmetatable({                          
    use = use;                                   
    select = select;                             
    match = match;                               
    data = packet:sub(4);                     
  }, tlsa_mt);                                   
end                                              

-- Acronyms from RFC 7218 
local tlsa_usages = {     
  [0] = "PKIX-CA",        
  [1] = "PKIX-EE",        
  [2] = "DANE-TA",        
  [3] = "DANE-EE",        
  [255] = "PrivCert",     
};                        
local tlsa_selectors = {  
  [0] = "Cert",           
  [1] = "SPKI",           
  [255] = "PrivSel",      
};                        
local tlsa_match_types = {
  [0] = "Full",           
  [1] = "SHA2-256",       
  [2] = "SHA2-512",       
  [255] = "PrivMatch",    
};                        

function tlsa_mt:__tostring()
	return ("%s %s %s %s"):format(
		tlsa_usages[self.use] or self.use,
		tlsa_selectors[self.select] or self.select,
		tlsa_match_types[self.match] or self.match,
		tohex(self.data));
end

-- from mod_s2s_auth_dane
local function one_dane_check(tlsa, cert)
  local select, match, certdata = tlsa.select, tlsa.match;

  if select == 0 then
    certdata = pem2der(cert:pem());
  elseif select == 1 and cert.pubkey then
    certdata = pem2der(cert:pubkey());
  else
    return nil, "select";
  end

  if match == 1 then
    certdata = hashes.sha256(certdata);
  elseif match == 2 then
    certdata = hashes.sha512(certdata);
  elseif match ~= 0 then
		return nil, "match";
  end
  return certdata == tlsa.data;
end


local starttls_blobs = {
	xmpp = [[<stream:stream xmlns:stream='http://etherx.jabber.org/streams' to='$to' from='$from' version='1.0' xmlns='jabber:$type'><starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>]];
}
local get_startts = {
	["xmpp-client"] = function (name)
		return starttls_blobs.xmpp:gsub("$(%w+)", {
			type = "client", from = "", to = name;
		});
	end;
	["xmpp-server"] = function (name)
		return starttls_blobs.xmpp:gsub("$(%w+)", {
			type = "server", from = "example.com", to = name;
		});
	end;
	-- TODO email etc
}

local name = table.remove(arg);
if not name then
	print(arg[0].." [--starttls=proto] example.com[@service.example.net[:port]]");
	return 
end
local target = name;
local port = 443;
if name:find("@") then
	name, target = name:match("^(.-)@(.*)$");
	if target:find(":") then
		target, port = target:match("^(.-):(.*)$");
		name = name:match("^[^:]+")
	end
end
local sock = socket.connect(target, port);
for i, arg in ipairs(arg) do
	local starttls = arg:match("^%-%-starttls=(.*)");
	if starttls then starttls = get_startts[starttls]; end
	if starttls then starttls = starttls(name, target); end
	if starttls then
		-- io.stderr:write("Sending: ", starttls,  "\n\n");
		sock:send(starttls);
		sock:settimeout(1);
		sock:receive("*a"); -- discard until asked to proceed with TLS
		sock:settimeout(0);
	end
end
sock = ssl.wrap(sock, {
	mode = "client",
	protocol = "tlsv1_2",
});
repeat until sock:dohandshake();

print("Name:", name);
print("Target:", target);
print("Port:", port);

local cert = sock:getpeercertificate();
print(cert:pem())

local resolver = unbound.new();
local reply = assert(resolver:resolve(("_%d._tcp.%s."):format(port, target), 52, 1));
print("TLSA response is "..(reply.bogus or (reply.secure and "Secure" or "Insecure")));
print();
for i = 1, reply.n do
	local tlsa = parse_TLSA(reply[i]);
	print(tlsa)
	if tlsa.use == 1 or tlsa.use == 3 then
		print(one_dane_check(tlsa, cert) and "Matches!" or "No match");
	else
		print("TODO CA-based usage");
	end
	print()
end
